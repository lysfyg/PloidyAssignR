#' Assign Consensus Ploidy
#'
#' This function finds the optimal k for the Watson-reads fraction distribution for
#' each segment determined using a sliding window by calWatsonFractions().
#'
#' @import data.table
#' @import assertthat
#'
#' @param dt_input_fractions Data.table generated by calWatsonFractions().
#' @param input_chrom Vector of chromosomes ("chr1, chr2...") supplied by user. Automatically extracts chromosomes from data set if not specified.
#' @param max_ploidy_force Maximum ploidy determined by number of cells within the sample. If not supplied by the user automatically determined from data set.
#'
#' @return Data.table with two new additional columns: "sil_k" is the optimal k determined by maximizing a silhouette score and "cons_ploidy" is the consensus ploidy value of each window inferred after kmeans clustering and k+1=n
#' @examples
#' # run ploidy assignment
#' K562_chr1_ploidy <- assignConsensusPloidy(data_K562_ploidy[,1:7], input_chrom = "chr1")
#' # plot results in karyogram style to inspect
#' fct_plot_karyogram(K562_chr1_ploidy)
#' @export
#'

assignConsensusPloidy <- function(
    dt_input_fractions,
    input_chrom = NULL,
    max_ploidy_force = NULL) {
    # to address "no visible binding for global variable"
    cell <- sil_k <- fraction_w <- cons_ploidy <- NULL
    # v dt_input_fractions is a data.table
    assertthat::assert_that(data.table::is.data.table(dt_input_fractions),
                            msg = "assignConsensusPloidy requires a data.table as input.")
    # v dt_input_fractions has correct format
    assertthat::assert_that("chrom" %in% colnames(dt_input_fractions),
        "start" %in% colnames(dt_input_fractions) && is.numeric(dt_input_fractions$start),
        "end" %in% colnames(dt_input_fractions) && is.numeric(dt_input_fractions$end),
        "sample" %in% colnames(dt_input_fractions),
        "cell" %in% colnames(dt_input_fractions),
        "fraction_w" %in% colnames(dt_input_fractions) && is.numeric(dt_input_fractions$fraction_w),
        "total_count" %in% colnames(dt_input_fractions) && is.numeric(dt_input_fractions$total_count),
        msg = "One or more required columns in your input file are missing for analysis. "
    )





    # v max_ploidy_force = Null, then extract max_ploidy automatically from data set
    if (is.null(max_ploidy_force)) {
        # min required cells for analysis for max_ploidy is 2^ploidy -> therefore using log2 to calculate max_ploidy
        max_ploidy <- trunc(log(length(dt_input_fractions[, unique(cell)]), base = 2))

        message("Your data set contains ", length(dt_input_fractions[, unique(cell)]),
                " cells. Consensus ploidy analysis is performed with max_ploidy = ", max_ploidy, ".\n")
    } else {
        max_ploidy <- max_ploidy_force
        message("You have forced max_ploidy to ", max_ploidy, ". Your data set contains ",
                length(dt_input_fractions[, unique(cell)]), " cells and therefore allows max_ploidy = ",
                trunc(log(length(dt_input_fractions[, unique(cell)]), base = 2)), ".\n")
    }
    # v If no input_chrom is given extract from input data set
    if (is.null(input_chrom)) {
        input_chrom <- extract_chromosomes(dt_input_fractions) # sort chromosomes
    } else {
        input_chrom <- extract_chromosomes(input_chrom) # sort chromosomes
    }
    message("Running analysis on ", paste(input_chrom, collapse = " "), ".\n")
    # initialize tmp data.table because otherwise changes would be made outside of function to original data.table
    dt_ploidy <- dt_input_fractions[input_chrom, on = "chrom"]
    # Silhouette Score analysis
    dt_ploidy[, sil_k := find_optimal_k(fraction_w, max_ploidy = max_ploidy), by = c("chrom", "start")]
    dt_ploidy[, cons_ploidy := (sil_k - 1)]

    return(dt_ploidy)
}
